<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Мой склад — Kaspi</title>
  <style>
    :root{
      --bg:#ffffff; --fg:#0f172a; --muted:#6b7280; --card:#f8fafc; --line:#e5e7eb;
      --pri:#1f7aee; --pri-weak:#e9eef6; --pill-bg:#eef2ff; --pill-fg:#3730a3;
      --ok-bg:#ecfdf5; --ok-fg:#065f46; --ok-border:#a7f3d0;
      --err-bg:#fef2f2; --err-fg:#991b1b; --err-border:#fecaca;
      --chip:#e2e8f0;
    }
    body[data-theme="dark"]{
      --bg:#0b1220; --fg:#e5e7eb; --muted:#94a3b8; --card:#0f1829; --line:#1f2a37;
      --pri:#3b82f6; --pri-weak:#132036; --pill-bg:#1e293b; --pill-fg:#bfdbfe;
      --ok-bg:#112a1f; --ok-fg:#a7f3d0; --ok-border:#134e4a;
      --err-bg:#3b0d0d; --err-fg:#fecaca; --err-border:#7f1d1d;
      --chip:#0f172a;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--fg);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
    .layout{display:grid;grid-template-columns:220px 1fr;min-height:100vh}
    .sidebar{border-right:1px solid var(--line);padding:16px 12px;position:sticky;top:0;height:100vh}
    .brand{font-weight:800;font-size:18px;margin:4px 0 12px}
    .nav{display:flex;flex-direction:column;gap:6px;margin-bottom:16px}
    .nav a{padding:8px 10px;border-radius:10px;color:var(--fg);opacity:.9;text-decoration:none}
    .nav a:hover{background:var(--card);opacity:1}
    .switch{display:flex;gap:8px;align-items:center;margin-top:auto;padding-top:12px;border-top:1px solid var(--line)}
    .switch input{width:40px;height:22px;appearance:none;background:var(--line);border-radius:999px;position:relative}
    .switch input:checked{background:var(--pri)}
    .switch input::after{content:"";position:absolute;inset:3px auto auto 3px;width:16px;height:16px;background:#fff;border-radius:50%;transition:left .2s}
    .switch input:checked::after{left:21px}
    .content{padding:20px 16px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .btn{background:var(--pri);color:#fff;border:0;border-radius:10px;padding:8px 12px;cursor:pointer}
    .btn.secondary{background:var(--pri-weak);color:var(--fg)}
    .btn-link{background:transparent;border:0;color:var(--pri);cursor:pointer;padding:0}
    input[type="text"],input[type="number"],input[type="date"],select{
      height:34px;padding:6px 8px;border:1px solid var(--line);border-radius:10px;background:transparent;color:var(--fg)
    }
    table{border-collapse:collapse;width:100%}
    th,td{border-bottom:1px solid var(--line);padding:8px 10px;text-align:left;vertical-align:middle}
    thead th{position:sticky;top:0;background:var(--card);z-index:1}
    .muted{color:var(--muted)}
    .dot{display:inline-block;width:10px;height:10px;border-radius:50%;background:#9ca3af}
    .dot.on{background:#10b981}
    .note{margin:8px 0 12px; padding:8px 10px;border-radius:8px;display:none}
    .note.ok{display:block;background:var(--ok-bg);color:var(--ok-fg);border:1px solid var(--ok-border)}
    .note.err{display:block;background:var(--err-bg);color:var(--err-fg);border:1px solid var(--err-border)}
    .detail{background:var(--card)}
    .block{padding:12px}
    .chip{display:inline-flex;align-items:center;gap:6px;background:var(--chip);color:var(--fg);padding:4px 8px;border-radius:999px;font-size:12px}
    .chip .dot{width:8px;height:8px}
    .spacer{flex:1}
  </style>
</head>
<body data-theme="light">
  <div class="layout">
    <aside class="sidebar">
      <div class="brand">⚡ LeoXpress</div>
      <nav class="nav">
        <a href="#" style="background:var(--card)">Мой склад</a>
        <a href="/ui/index.html">Аналитика</a>
        <a href="#">Предзаказ</a>
        <a href="#">Демпинг</a>
        <a href="#">WhatsApp-рассылка</a>
      </nav>
      <div class="switch">
        <input id="themeToggle" type="checkbox" />
        <label for="themeToggle">Тёмная тема</label>
      </div>
    </aside>

    <main class="content">
      <div class="row" style="align-items:baseline; margin-bottom:6px">
        <h1 style="margin:0">Мой склад</h1>
        <div class="spacer"></div>
        <!-- Бейдж списаний за текущий бизнес-день -->
        <span id="woBadge" class="chip" title="Списаний за сегодня (бизнес-день)">
          <span class="dot on"></span>
          <span>Списаний сегодня: <b id="woCount">0</b> (шт: <b id="woQty">0</b>)</span>
        </span>
      </div>

      <div class="row" style="margin-bottom:10px">
        <label><input id="onlyActive" type="checkbox" checked> Только активные</label>
        <input id="search" type="text" placeholder="Название, код, бренд..." style="min-width:260px">
        <!-- быстрый переход к SKU -->
        <input id="findSku" type="text" placeholder="SKU" style="width:160px">
        <button class="btn secondary" id="btnFindSku">Открыть SKU</button>

        <button class="btn" id="btnLoadApi">Загрузить</button>
        <label class="btn secondary" for="fileInput">Импорт из файла (XML/XLSX)</label>
        <input type="file" id="fileInput" accept=".xml,.xlsx,.xls" style="display:none">
        <button class="btn secondary" id="btnSaveDb">Сохранить таблицу в БД</button>
        <button class="btn secondary" id="btnExportDb">Экспорт CSV (БД)</button>
        <button class="btn secondary" id="btnLoadDb">Загрузить из БД</button>
        <button class="btn secondary" id="btnApiKey">API-Key</button>
        <span id="apiKeyBadge" class="chip"><span class="dot"></span><span>ключ не задан</span></span>

        <!-- элементы только для локальной SQLite -->
        <button class="btn secondary" id="btnBackup" data-sqlite-only>Бэкап БД</button>
        <label class="btn secondary" for="restoreFile" data-sqlite-only>Восстановить БД</label>
        <input type="file" id="restoreFile" accept=".sqlite3" style="display:none" data-sqlite-only>
      </div>

      <div id="note" class="note"></div>

      <div class="shell">
        <div style="overflow:auto; max-height:70vh">
          <table id="tbl">
            <thead>
              <tr>
                <th style="min-width:160px">Код</th>
                <th style="min-width:360px">Название</th>
                <th>Бренд</th>
                <th>Категория</th>
                <th>ШТ</th>
                <th>Цена, KZT</th>
                <th>Активен</th>
                <th>Остаток (партии)</th>
                <th>Кол-во партий</th>
                <th>Маржа (посл.), KZT</th>
                <th class="col-right">Партии</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </main>
  </div>

<script type="module">
const qs=(s,el=document)=>el.querySelector(s);
const qsa=(s,el=document)=>[...el.querySelectorAll(s)];
const nf = new Intl.NumberFormat('ru-RU');
const fmt = n => nf.format(Number(n||0));

function setNote(msg, ok=false){
  const el = qs('#note');
  el.textContent = msg;
  el.className = 'note ' + (ok ? 'ok':'err');
}

(function initTheme(){
  const saved = localStorage.getItem('theme') || 'light';
  document.body.setAttribute('data-theme', saved);
  qs('#themeToggle').checked = saved === 'dark';
  qs('#themeToggle').addEventListener('change', e=>{
    const t = e.target.checked ? 'dark' : 'light';
    document.body.setAttribute('data-theme', t);
    localStorage.setItem('theme', t);
  });
})();

// --- Fetch helper с автоповтором при 401/403 (запрос ключа) ---
async function fetchJSON(url, opts, _retry){
  const r = await fetch(url, opts||{});
  if(r.status===401 || r.status===403){
    if(!_retry){
      const curr = window.KASPI_API_KEY || "";
      const v = prompt("Укажите X-API-Key (сохранится в этом браузере):", curr);
      if(v!==null){ window.setApiKey(v.trim()); return fetchJSON(url, opts, true); }
    }
    const txt = await r.text();
    throw new Error(txt || 'Unauthorized');
  }
  if(!r.ok){
    const txt = await r.text();
    throw new Error(txt || r.statusText || 'HTTP ' + r.status);
  }
  const ct = r.headers.get('content-type')||'';
  return ct.includes('application/json') ? r.json() : r.text();
}

function parsePriceCell(cell){ return Number((cell?.textContent||'0').toString().replace(/\s/g,'')); }

function renderProducts(items){
  const tb = qs('#tbl tbody');
  tb.innerHTML = '';
  items.forEach(it=>{
    const tr = document.createElement('tr');
    const sku = it.code || it.id || '';
    tr.dataset.sku = sku;
    tr.innerHTML = `
      <td>${sku}</td>
      <td>${it.name||''}</td>
      <td>${it.brand||''}</td>
      <td>${it.category||''}</td>
      <td>${fmt(it.qty||0)}</td>
      <td>${fmt(it.price||0)}</td>
      <td><span class="dot ${((it.qty||0)>0 || it.active===true) ? 'on':''}"></span></td>
      <td>${fmt(it.left_total ?? 0)}</td>
      <td>${fmt(it.batch_count||0)}</td>
      <td>${it.last_margin!=null ? fmt(it.last_margin) : '—'}</td>
      <td class="col-right"><button class="btn-link btn-parties">Партии</button></td>
    `;
    tb.appendChild(tr);
  });
}

async function loadAPI(){
  try{
    const p = new URLSearchParams();
    p.set('active', qs('#onlyActive').checked ? '1' : '0');
    const q = qs('#search').value.trim(); if(q) p.set('q', q);
    p.set('page','1'); p.set('page_size','2000');
    const data = await fetchJSON('/products/list?'+p.toString());
    setNote('Каталог из API загружен: ' + (data.items?.length||0) + ' поз.', true);
    renderProducts(data.items||[]);
  }catch(e){ setNote('Ошибка загрузки из API: ' + e.message); }
}

async function loadDB(){
  try{
    const p = new URLSearchParams();
    p.set('active_only', qs('#onlyActive').checked ? '1' : '0');
    const q = qs('#search').value.trim(); if(q) p.set('search', q);
    const data = await fetchJSON('/products/db/list?'+p.toString());
    setNote('Загружено строк из БД: ' + (data.items?.length||0), true);
    renderProducts(data.items||[]);
  }catch(e){ setNote('Сеть: ' + e.message); }
}

async function importFile(file){
  const fd = new FormData(); fd.append('file', file);
  try{
    const data = await fetchJSON('/products/manual-upload', {method:'POST', body:fd});
    setNote(`Файл загружен: ${file.name}. Позиции: ${data.count||0}. Вставлено: ${data.inserted||0}, обновлено: ${data.updated||0}`, true);
    renderProducts(data.items||[]);
  }catch(e){ setNote('Импорт не удался: ' + e.message); }
}

function clearDetails(){ qsa('tr.detail').forEach(tr => tr.remove()); }
function makeDetailRow(colspan){
  const tr = document.createElement('tr'); tr.className='detail';
  const td = document.createElement('td'); td.colSpan = colspan; tr.appendChild(td); return tr;
}

async function openDetail(row){
  clearDetails();
  const sku = row?.dataset?.sku || row.cells?.[0]?.textContent?.trim();
  if(!sku){ setNote('У товара нет кода/sku — некуда сохранять партии.'); return; }

  const tr = makeDetailRow(row.children.length);
  row.insertAdjacentElement('afterend', tr);
  const mount = tr.firstChild;

  // ⚠️ Убраны ручные кнопки пересчёта/списаний — остаётся только работа с партиями
  mount.innerHTML = `
    <div class="block">
      <div style="display:flex;align-items:center;gap:10px;margin:8px 0 6px">
        <div style="font-weight:600">Партии — <span id="dTitle">${row.cells[1].textContent}</span></div>
      </div>

      <table style="width:100%" id="btTable">
        <thead>
          <tr>
            <th>Дата</th><th>Кол-во</th><th>Закуп., KZT</th><th>Комиссия, %</th>
            <th>Маржа / шт</th><th>Продано</th><th>Остаток</th><th>Код</th><th>Прим.</th><th></th>
          </tr>
        </thead>
        <tbody id="btBody"></tbody>
      </table>

      <div class="row" style="margin-top:8px; gap:8px">
        <button class="btn secondary" id="btnAddRow">+ Добавить</button>
        <button class="btn" id="btnSaveRows">Сохранить новые</button>
      </div>
    </div>
  `;

  const tbody = qs('#btBody', mount);
  const priceKZT = parsePriceCell(row.cells[5]);

  function recalc(tr){
    const inputs = tr.querySelectorAll('input');
    const uc = Number(inputs[2].value||0);
    const comm = Number(inputs[3].value||0);
    const net = priceKZT - (priceKZT * comm/100) - uc;
    tr.querySelector('.net').textContent = isFinite(net) ? fmt(net) : '—';
  }

  function addRow(data={}){
    const tr = document.createElement('tr');
    const codeCell = (data && data.batch_code) ? data.batch_code : '<span class="muted">— генерируется</span>';
    const delBtn = (data && data.id) ? `<button class="btn-link btnDel" data-id="${data.id}">Удалить</button>` : '';
    const sold = data.qty_sold ?? data.sold ?? null;
    const left = data.left ?? (typeof sold === 'number' && typeof data.qty === 'number' ? (data.qty - sold) : null);
    tr.innerHTML = `
      <td><input type="date" value="${data.date || new Date().toISOString().slice(0,10)}"></td>
      <td><input type="number" min="0" step="1" value="${data.qty ?? ''}" style="width:90px"></td>
      <td><input type="number" min="0" step="0.01" value="${data.unit_cost ?? ''}" style="width:110px"></td>
      <td><input type="number" min="0" step="0.01" value="${data.commission_pct ?? ''}" style="width:100px"></td>
      <td class="net">—</td>
      <td>${sold != null ? fmt(sold) : '—'}</td>
      <td>${left != null ? fmt(left) : '—'}</td>
      <td class="code">${codeCell}</td>
      <td><input type="text" value="${data.note ?? ''}"></td>
      <td>${delBtn}</td>
    `;
    tbody.appendChild(tr);
    recalc(tr);
  }

  try{
    const data = await fetchJSON('/products/db/price-batches/'+encodeURIComponent(sku));
    (data.batches||[]).forEach(addRow);
  }catch(e){ setNote('Не удалось загрузить партии: ' + e.message); }

  qs('#btnAddRow', mount).onclick = ()=> addRow({});
  tbody.addEventListener('input', e=>{ const tr = e.target.closest('tr'); if(tr) recalc(tr); });
  tbody.addEventListener('click', async (e)=>{
    const btn = e.target.closest('.btnDel'); if(!btn) return;
    try{
      await fetchJSON('/products/db/price-batches/'+encodeURIComponent(sku)+'/'+btn.dataset.id, {method:'DELETE'});
      btn.closest('tr').remove();
      setNote('Партия удалена.', true);
      await updateWriteoffsChip(); // косметически обновим бейдж
      await loadDB();
    }catch(err){ setNote('Удаление не удалось: ' + err.message); }
  });

  qs('#btnSaveRows', mount).onclick = async ()=>{
    const entries = qsa('tr', tbody).map(tr=>{
      const ins = tr.querySelectorAll('input');
      const codeText = tr.querySelector('.code')?.textContent?.trim() || '';
      const gen = codeText.startsWith('—') ? null : codeText;
      return {
        date: ins[0].value,
        qty: Number(ins[1].value||0),
        unit_cost: Number(ins[2].value||0),
        commission_pct: Number(ins[3].value||0) || null,
        note: ins[4].value || null,
        batch_code: gen
      };
    }).filter(e => e.qty>0 && e.unit_cost>0);
    if(!entries.length){ setNote('Добавьте хотя бы одну строку партии.'); return; }
    try{
      await fetchJSON('/products/db/price-batches/'+encodeURIComponent(sku), {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({entries})
      });
      setNote('Партии сохранены.', true);
      await updateWriteoffsChip();
      openDetail(row); // перезагрузим
    }catch(e){ setNote('Сохранение партий не удалось: ' + e.message); }
  };
}

function tableToRows(){
  return qsa('#tbl tbody tr').map(tr=>{
    const t = tr.children;
    const code = t[0].textContent.trim();
    const name = t[1].textContent.trim();
    const brand = t[2].textContent.trim() || null;
    const category = t[3].textContent.trim() || null;
    const qty = parseInt(t[4].textContent.replace(/\s/g,'')) || 0;
    const price = parseFloat(t[5].textContent.replace(/\s/g,'')) || 0;
    const active = t[6].querySelector('.dot')?.classList.contains('on') || false;
    return { code, name, brand, category, qty, price, active };
  });
}

// === Авто-синк продаж → леджер → списания (без кнопок) ===
async function getStoreHours(){
  try{
    const j = await fetchJSON('/api/settings/store-hours');
    return {
      use_bd: 1,
      bd_start: (j?.business_day_start || '20:00'),
      tz: (j?.timezone || 'Asia/Almaty')
    };
  }catch(_){
    return { use_bd: 1, bd_start:'20:00', tz:'Asia/Almaty' };
  }
}
function businessDayWindow(bd_start='20:00', tz='Asia/Almaty'){
  // простая реализация: Asia/Almaty => +5 часов
  const tzOffsetMin = Number(localStorage.getItem('TZ_OFFSET_MIN')) || (tz==='Asia/Almaty' ? 300 : 0);
  const nowUTC = new Date();
  const nowLocal = new Date(nowUTC.getTime() + tzOffsetMin*60000);
  const [hh,mm] = bd_start.split(':').map(Number);
  const startLocal = new Date(nowLocal); startLocal.setHours(hh||0, mm||0, 0, 0);
  if(nowLocal < startLocal) startLocal.setDate(startLocal.getDate()-1);
  const endLocal = new Date(startLocal); endLocal.setDate(endLocal.getDate()+1);
  const startUTC = new Date(startLocal.getTime() - tzOffsetMin*60000);
  const endUTC   = new Date(endLocal.getTime() - tzOffsetMin*60000);
  return { startUTC, endUTC, tzOffsetMin };
}

async function autoSyncWriteoffs(){
  try{
    setNote('Автосинхронизация списаний…');
    const { bd_start, tz } = await getStoreHours();

    // ✅ для бизнес-дня используем только дату (YYYY-MM-DD)
    const day = new Date().toISOString().slice(0,10);

    // 1) тянем заказы за текущий бизнес-день (без времени, use_bd=1)
    const p = new URLSearchParams({
      start: day,
      end: day,
      tz,
      date_field: 'creationDate',
      states: 'KASPI_DELIVERY',
      exclude_states: 'CANCELED',
      use_bd: '1',
      business_day_start: bd_start,
      order: 'desc',
      grouped: '0',
      limit: '100000',
      with_items: '1'
    });
    const data = await fetchJSON('/orders/ids?' + p.toString());
    const rows = data.items || [];

    // 2) собираем заказы → upsert
    const byId = new Map();
    for (const r of rows) {
      const oid = String(r.id || r.number || r.orderId || ''); if (!oid) continue;
      if (!byId.has(oid)) byId.set(oid, { id: oid, date: r.date || r.creationDate || (day + 'T00:00:00'), customer: null, items: [] });
      const sku = String(r.sku || r.code || r.vendorCode || r.barcode || ''); if (!sku) continue;
      const unit_price = Number(r.amount || r.price || 0);
      const pkg = byId.get(oid);
      const ex = pkg.items.find(it => it.sku === sku);
      if (ex) { ex.qty += 1; ex.unit_price = unit_price || ex.unit_price; }
      else { pkg.items.push({ sku, qty: 1, unit_price }); }
    }
    const orders = [...byId.values()];

    if (!orders.length) {
      await updateWriteoffsChip();
      setNote('Автосинхронизация: нет продаж за бизнес-день.', true);
      return;
    }

    await fetchJSON('/profit/orders/upsert-bulk', {
      method:'POST', headers:{'Content-Type':'application/json'},
      body: JSON.stringify({ orders })
    });

    // 3) пересобираем леджер за этот же день
    const q2 = new URLSearchParams({ date_from: day, date_to: day });
    await fetchJSON('/profit/rebuild-ledger?' + q2.toString(), { method:'POST' });

    // 4) протягиваем qty_sold
    await fetchJSON('/products/batches/recount-sold', { method:'POST' });

    await updateWriteoffsChip();
    await loadDB();
    setNote('Автосинхронизация списаний выполнена.', true);
  }catch(e){
    // на случай 400/сетевых — мягко показываем сообщение, не валим страницу
    setNote('Автосинхронизация не удалась: ' + (e?.message || e), false);
  }
}

// === Бейдж списаний в шапке ===
async function updateWriteoffsChip(){
  try{
    const { bd_start, tz } = await getStoreHours();
    const p = new URLSearchParams({ use_bd:'1', bd_start, tz });
    const j = await fetchJSON('/products/db/writeoffs/header?'+p.toString());
    qs('#woCount').textContent = (j?.count ?? 0);
    qs('#woQty').textContent = (j?.total_qty ?? 0);
  }catch(_){}
}

document.addEventListener('DOMContentLoaded', async ()=>{
  // ping: показываем безопасный драйвер, без подробностей урла
  try{
    const ping = await fetchJSON('/products/db/ping');
    const backend = ping?.driver ? ('db=' + ping.driver) : (ping?.db_path || '');
    setNote('Бэкенд OK (integrity=' + (ping.ok ? 'ok':'fail') + '; ' + backend + ')', true);
  }catch(e){
    setNote('Не найден /products/db/ping. Проверь main.py -> include_router(..., prefix="/products").');
  }

  qs('#btnLoadApi').onclick = loadAPI;
  qs('#btnLoadDb').onclick = loadDB;

  // быстрый поиск/открытие SKU
  qs('#btnFindSku').onclick = ()=>{
    const sku = qs('#findSku').value.trim();
    if(!sku) return;
    const row = qsa('#tbl tbody tr').find(tr => (tr.dataset.sku||tr.cells[0].textContent.trim()) === sku);
    if(!row){ setNote('SKU не найден в таблице. Попробуй «Загрузить из БД» или общий поиск.'); return; }
    row.scrollIntoView({behavior:'smooth', block:'center'});
    openDetail(row);
  };

  qs('#fileInput').addEventListener('change', async (e)=>{
    const f = e.target.files?.[0]; if(!f) return;
    await importFile(f); e.target.value = '';
  });

  qs('#restoreFile').addEventListener('change', async (e)=>{
    const f = e.target.files?.[0]; if(!f) return;
    const fd = new FormData(); fd.append('file', f);
    try{
      const res = await fetchJSON('/products/db/restore', {method:'POST', body:fd});
      if(res?.integrity === 'ok') setNote('БД восстановлена (integrity=ok).', true);
      else setNote('БД загружена, но integrity_check != ok.');
      await loadDB();
      await updateWriteoffsChip();
    }catch(err){ setNote('Восстановление БД не удалось: ' + err.message); }
    e.target.value = '';
  });

  const backupBtn = qs('#btnBackup');
  if(backupBtn) backupBtn.onclick = ()=> { window.location = '/products/db/backup.sqlite3'; };

  qs('#tbl').addEventListener('click', (e)=>{
    const btn = e.target.closest('.btn-parties'); if(!btn) return;
    openDetail(btn.closest('tr'));
  });

  qs('#btnSaveDb').onclick = async ()=>{
    const rows = tableToRows();
    if(!rows.length){ setNote('Нет строк для сохранения. Сначала загрузите товары из API/файла.'); return; }
    try{
      const res = await fetchJSON('/products/db/bulk-upsert', {
        method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(rows)
      });
      setNote(`Сохранено в БД: вставлено ${res.inserted||0}, обновлено ${res.updated||0}`, true);
      await loadDB();
      await updateWriteoffsChip();
    }catch(e){ setNote('Сохранение в БД не удалось: ' + e.message); }
  };

  qs('#btnExportDb').onclick = ()=>{
    const p = new URLSearchParams();
    p.set('active_only', qs('#onlyActive').checked ? '1' : '0');
    const q = qs('#search').value.trim(); if(q) p.set('search', q);
    window.location = '/products/db/export.csv?' + p.toString();
  };

  // 1) Авто-синк списаний (за текущий бизнес-день)
  await autoSyncWriteoffs();

  // 2) Загрузим БД и бейдж (на случай пустой синхронизации)
  await loadDB();
  await updateWriteoffsChip();
});
</script>

<!-- Автоподстановка X-API-Key ко всем запросам /products/* и /profit/* + статус ключа -->
<script>
(() => {
  const KEY = "KASPI_API_KEY";
  const badge = () => document.getElementById('apiKeyBadge');

  function refreshKeyBadge(){
    const v = localStorage.getItem(KEY) || "";
    const el = badge(); if(!el) return;
    const dot = el.querySelector('.dot'); const text = el.querySelector('span:last-child');
    if(v){
      dot.classList.add('on');
      text.textContent = 'ключ установлен';
    }else{
      dot.classList.remove('on');
      text.textContent = 'ключ не задан';
    }
  }

  window.KASPI_API_KEY = localStorage.getItem(KEY) || "";
  refreshKeyBadge();

  const _origFetch = window.fetch.bind(window);
  window.fetch = function(input, init) {
    try {
      let urlStr = typeof input === "string" ? input : (input && input.url) || "";
      if (urlStr.startsWith("/products/") || urlStr.startsWith("/profit/")) {
        init = init || {};
        const k = window.KASPI_API_KEY || "";

        // Заголовок
        let headers = init.headers instanceof Headers ? init.headers : new Headers(init.headers || {});
        if (k) headers.set("X-API-Key", k);
        init.headers = headers;

        // Fallback: подпишем ?api_key=... (на тот же ключ)
        if (k) {
          const u = new URL(urlStr, location.origin);
          if (!u.searchParams.has("api_key")) u.searchParams.set("api_key", k);
          if (typeof input === "string") {
            input = u.pathname + u.search;
          } else {
            input = new Request(u.toString(), init);
          }
        }
      }
    } catch (e) { /* no-op */ }
    return _origFetch(input, init);
  };

  // Удобный setter (сохранит ключ и тут же начнёт подставлять)
  window.setApiKey = function(k) {
    localStorage.setItem(KEY, k || "");
    window.KASPI_API_KEY = k || "";
    refreshKeyBadge();
    console.log("API key set");
  };

  // Кнопка "API-Key": спросить и сохранить
  document.addEventListener("DOMContentLoaded", () => {
    const btn = document.getElementById("btnApiKey");
    if (btn) {
      btn.addEventListener("click", () => {
        const curr = window.KASPI_API_KEY || "";
        const v = prompt("Введите X-API-Key (сохранится в этом браузере):", curr);
        if (v !== null) { setApiKey(v.trim()); alert("Сохранено. Повторите действие."); }
      });
    }
  });
})();
</script>

<!-- Скрыть элементы с data-sqlite-only в режиме Postgres -->
<script>
document.addEventListener("DOMContentLoaded", async () => {
  let isPG = false;
  try {
    const r = await fetch("/products/db/ping");
    const j = await r.json();
    if (j && typeof j.driver === "string") {
      isPG = (j.driver === "pg");
    } else if (j && j.db_path) {
      isPG = String(j.db_path).startsWith("postgres");
    }
  } catch (e) {}

  if (!isPG) return;

  const hide = (el) => { if (el) el.style.display = "none"; };

  hide(document.querySelector('a[href$="/products/db/backup.sqlite3"]'));
  hide(document.querySelector('button[data-action="backup"]'));
  document.querySelectorAll('form[action$="/products/db/restore"]').forEach(hide);
  document.querySelectorAll('button[data-action="restore"]').forEach(hide);
  document.querySelectorAll("[data-sqlite-only]").forEach(hide);
  // Fallback по тексту
  document.querySelectorAll("button, a, form, div, section").forEach((el) => {
    const t = (el.innerText || "").toLowerCase();
    if (/(backup|бэкап|restore|восстанов)/.test(t)) hide(el);
  });
});
</script>

</body>
</html>
